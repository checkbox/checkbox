#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# This file is part of Checkbox.
#
# Copyright 2016 Canonical Ltd.
#
# Authors:
#    Po-Hsu Lin <po-hsu.lin@canonical.com>
#    Yung Shen <yung.shen@canonical.com>
#
# Checkbox is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3,
# as published by the Free Software Foundation.
#
# Checkbox is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Checkbox.  If not, see <http://www.gnu.org/licenses/>.

#
# possibility to lockup, if it times out
# TODO:
#       6. different PIN selection
#       7. MAC address validator
#       8. Use logging for information

import sys
import time

import bt_helper

from argparse import ArgumentParser


def unpairing(devices, manager):
    """ Unpairing paired devices and scanning again for rerun jobs. """
    for dev in devices:
        try:
            print("INFO: Unpairing known device")
            dev.unpair()
        except bt_helper.BtException as state:
            print("Warning: Unpairing failed", state)
        break
    else:
        return
    print("INFO: Please reset the device to pairing mode")
    countdown_timer(13)
    print("INFO: Re-scaning for devices in pairing mode")
    manager.scan()


def countdown_timer(sec):
    """ Give user some more awareness while waiting. """
    for i in range(sec, -1, -1):
        sys.stdout.write("\rINFO: Re-parining in {:2}s".format(i))
        sys.stdout.flush()
        time.sleep(1)
    print("\r")


def main():
    """ Add argument parser here and do most of the job. """
    parser = ArgumentParser(description=("Bluetooth auto paring and connect. "
                                         "Please select one option."))
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--mac", type=str,
                       help="Pair with a given MAC, not using scan result,")
    group.add_argument("--mouse", action="store_const",
                       const="input-mouse", dest='target',
                       help="List and pair with mouse devices")
    group.add_argument("--keyboard", action="store_const",
                       const="input-keyboard", dest='target',
                       help="List and pair with keyboard devices")
    args = parser.parse_args()

    manager = bt_helper.BtManager()
    # Power on bluetooth adapter and scanning devices in advance.
    manager.ensure_adapters_powered()
    manager.scan()

    if args.mac:
        # TODO check MAC format
        print("INFO: Trying to pair with {}".format(args.mac))
        device = list(manager.get_bt_devices(filters={'Address': args.mac}))
        paired_device = list(manager.get_bt_devices(
            filters={'Address': args.mac, 'Paired': True}))
        if not device:
            print("ERROR: No pairable device found, terminating")
            return 1

        unpairing(paired_device, manager)

        for dev in device:
            try:
                dev.pair()
            except bt_helper.BtException as state:
                print("ERROR: Unable to pair: ", state)
                return 1
            else:
                print("INFO: Device paired")
                return 0
    else:
        print("INFO: Listing targeting devices")
        # Listing device based on RSSI
        paired_targets = list(manager.get_bt_devices(category=bt_helper.BT_ANY,
                              filters={'Paired': True, 'Icon': args.target}))
        if not paired_targets:
            print("INFO: No paired targeting devices found")
            manager.scan()
        else:
            unpairing(paired_targets, manager)

        target_devices = sorted(manager.get_bt_devices(
            category=bt_helper.BT_ANY, filters={
             'Paired': False, 'Icon': args.target}),
             key=lambda x: int(x.rssi or -255), reverse=True)
        if not target_devices:
            print("ERROR: No target devices found, terminating")
            return 1
        print('INFO: Detected devices (sorted by RSSI; highest first).')
        # let's assing numbers to devices
        devices = dict(enumerate(target_devices, 1))
        for num, dev in devices.items():
            print('{}. {} (RSSI: {})'.format(num, dev, dev.rssi))
        chosen = False
        while not chosen:
            # print(flush=True) to bypass plainbox print() buffer.
            print('Which one would you like to connect to? (0 to exit)',
                  flush=True)
            num = input()
            # TODO: enter as default to 1st device
            if num == '0':
                return 1
            chosen = num.isnumeric() and int(num) in devices.keys()
        print('INFO: {} chosen.'.format(devices[int(num)]))
        print("INFO: Pairing selected device..")
        try:
            devices[int(num)].pair()
        except bt_helper.BtException as state:
            print("ERROR: something wrong: ", state)
            return 1
        else:
            print("Paired successfully.")
            return 0
    # capture all other silence failures
    return 1

if __name__ == "__main__":
    sys.exit(main())
