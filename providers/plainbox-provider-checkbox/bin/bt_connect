#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# This file is part of Checkbox.
#
# Copyright 2016 Canonical Ltd.
#
# Authors:
#    Po-Hsu Lin <po-hsu.lin@canonical.com>
#    Yung Shen <yung.shen@canonical.com>
#
# Checkbox is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3,
# as published by the Free Software Foundation.
#
# Checkbox is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Checkbox.  If not, see <http://www.gnu.org/licenses/>.

#
# possibility to lockup, if it times out
# TODO:
#       4. adapting bluez5 stack based on: https://github.com/kissiel/bt_helper
#       5. better exception handling (wrong PIN, authentication rejected)
#       6. different PIN selection
#       7. MAC address validator
#       8. Use logging for information
#       9. PEP8

import sys
import time
import pdb
import bt_helper

from argparse import ArgumentParser


def main():
    """Add argument parser here and do most of the job."""
    parser = ArgumentParser(description="Bluetooth auto paring and connect. Please select one option.")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--mac", type=str,
                       help="Pair with a given MAC, not using scan result,")
    group.add_argument("--mouse", action="store_const",
                       const="input-mouse", dest='target',
                       help="Pair with the last mouse found from scan result.")
    group.add_argument("--keyboard", action="store_const",
                       const="input-keyboard", dest='target',
                       help="Pair with the last keyboard found from scan result.")
    # TODO: TBD,
    #   not many use case will have multiple bt interface and besides dbus should handle different naming.
    #parser.add_argument("-i", "--interface", type=str,
    #                    help="Device interface, e.g. hci0")
    #
    # TODO: TBD, not sure about this part
    #parser.add_argument("-c", "--capability", type=str, default="DisplayYesNo")
    #
    args = parser.parse_args()
    
    manager = bt_helper.BtManager()

    # Power on device and scaning in advance.
    manager.ensure_adapters_powered()    
    manager.scan()

    if args.mac: 
        DEVICE_MAC = args.mac
        print("Trying to pair with {}.".format(DEVICE_MAC))
        DEVICE = list(manager.get_bt_devices(filters={'Address': DEVICE_MAC}))
       
        if not DEVICE:
            print("ERROR: No pairable device found, terminating")
            return 1
         
        for paireddevice in list(manager.get_bt_devices(filters={'Address': DEVICE_MAC, 'Paired': True})):
            paireddevice.unpair()
            print("Already paired, please reset the device to pairing mode..")
            # Give tester some more awareness           
            for i in range(0,11,1):
                sys.stdout.write("\r"+str(i))
                sys.stdout.flush()
                time.sleep(1)
            print("\n")
        
        # Todo:
        # if device is not listed should return status code: 1
        
        for device in list(manager.get_bt_devices(filters={'Address': DEVICE_MAC})):
            device.pair()
            print("Device paired")
            return 0
        
    else:
        TARGET = args.target
        print("Listing existing device")
        #Listing device based on RSSI
        devices = sorted(manager.get_bt_devices(
            category=bt_helper.BT_ANY, filters={'Paired': False, 'Icon': TARGET}),
             key=lambda x: int(x.rssi or -255), reverse=True)
        
        if not devices:
            print("Error: No devices detected")
            return 1
    
        print('Detected devices (sorted by RSSI; highest first).')
        # let's assing numbers to devices
        devices = dict(enumerate(devices, 1))
        
        # TODO: TBD,
        # may considering unpair every paired TARGET devices first?
        for paireddevice in list(manager.get_bt_devices(filters={'Icon': TARGET, 'Paired': True})):
            print("Unpairing known device: {}".format(paireddevice))
            paireddevice.unpair()
         
        for num, dev in devices.items():
            print('{}. {} (RSSI: {})'.format(num, dev, dev.rssi))
            chosen = False
        while not chosen:
            num = input('Which one would you like to connect to? (0 to exit) ')
            #TODO: enter to default
            if num == '0':
                return 1
            chosen = num.isnumeric() and int(num) in devices.keys()
        print('{} chosen.'.format(devices[int(num)]))
        print("Pairing selected device..")

        pdb.set_trace()

        # TODO:
        #   capture .pair() is failing
        #   however it's only returning None even it's failing
        #   https://github.com/kissiel/bt_helper/issues/11
        try:
            devices[int(num)].pair()
        except:
            print("ERROR: something wrong..")
            return 1
        else:
            return 0

if __name__ == "__main__":
    sys.exit(main())
