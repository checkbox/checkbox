#!/usr/bin/env python3
# this file is part of checkbox.
#
# copyright 2014 canonical ltd.
# written by:
#   maciej kisielewski <maciej.kisielewski@canonical.com>
#
# checkbox is free software: you can redistribute it and/or modify
# it under the terms of the gnu general public license version 3,
# as published by the free software foundation.
#
# checkbox is distributed in the hope that it will be useful,
# but without any warranty; without even the implied warranty of
# merchantability or fitness for a particular purpose.  see the
# gnu general public license for more details.
#
# you should have received a copy of the gnu general public license
# along with checkbox.  if not, see <http://www.gnu.org/licenses/>.
"""
Download and extract .deb packages necessary to run checkbox-touch
Extraction is done to specific directories as required by click package
"""

import apt
import apt_pkg
import os
import shutil
import subprocess
import tarfile
import tempfile
import urllib.request
from distutils.dir_util import copy_tree


def get_package_uri(pkg_name, arch):
    print('Getting information about {0} package for {1} arch.'.format(
        pkg_name, arch))
    repos = {
        'armhf': 'http://ports.ubuntu.com/ubuntu-ports',
        'i386': 'http://archive.ubuntu.com/ubuntu',
        'amd64': 'http://archive.ubuntu.com/ubuntu'
    }
    # prepare sources.list for apt
    with tempfile.TemporaryDirectory() as tmp:
        new_etc_apt = os.path.join(tmp, 'etc', 'apt')
        os.makedirs(new_etc_apt)
        # copy over trusted.gpg
        shutil.copyfile(os.path.join('/', 'etc', 'apt', 'trusted.gpg'),
                        os.path.join(new_etc_apt, 'trusted.gpg'))
        sources_list = open(os.path.join(new_etc_apt, 'sources.list'), "w")
        sources_list.write(
            "deb [arch={arch}] {repo} utopic main restricted universe".format(
                arch=arch, repo=repos[arch]))
        sources_list.close()
        apt_pkg.config["Apt::Architecture"] = arch
        cache = apt.Cache(rootdir=tmp)
        cache.update()
        cache.open(None)
        if pkg_name not in cache or len(cache[pkg_name].versions) < 1:
            # package not found
            raise Exception('Package {0} not found for arch {1}'.format(
                pkg_name, arch))
        # return first candidate
        return cache[pkg_name].versions[0].uri

# arch_list contains list of architectures for which the packages should be
# downloaded
arch_list = ['i386', 'amd64', 'armhf']
# multiarch_list contains full architecture name as used in the directories
# in contents of click package
multiarch_list = ["i386-linux-gnu", "x86_64-linux-gnu", "arm-linux-gnueabihf"]

plainbox_pypi = ('https://pypi.python.org/packages/source'
                 '/p/plainbox/plainbox-0.10.tar.gz')

# LIBS_URLS contains list of .deb packages that will be downloaded and
# extracted. After extraction contents of ./usr/lib are copied to ./lib
LIBS_URLS = [get_package_uri('libpython3.4', arch) for arch in arch_list]

# QML_PLUGINS_URL contains list of .deb packages that will be downloaded and
# and extracted. After extraction contents of ./usr/lib/{architecture}/qt5/qml
# are copied to ./lib/{architecture}. {architecture} may be one of ARCH_LIST
QML_PLUGINS_URLS = [
    get_package_uri('pyotherside', arch) for arch in arch_list]

# PYTHON3_LIBS_URLS contains list of .deb packages that will be downloaded and
# extracted. After extraction contents of ./usr/lib/python3/dist-packages
# are copied to ./py.
PYTHON3_LIBS_URLS = [
    get_package_uri('python3-lxml', arch) for arch in arch_list]


def get_package_from_url_and_extract(url, target_dir):
    filename = os.path.join(target_dir, url.split('/')[-1])
    print('retrieving {0}'.format(url))
    urllib.request.urlretrieve(url, filename)
    subprocess.check_call(["dpkg", "-x", filename, target_dir])


def main():
    with tempfile.TemporaryDirectory() as tmp:
        filename = os.path.join(tmp, plainbox_pypi.split('/')[-1])
        print('retrieving {0}'.format(plainbox_pypi))
        urllib.request.urlretrieve(plainbox_pypi, filename)
        tarball = tarfile.open(filename)
        members = [member for member in tarball.getmembers()
                   if member.name.startswith("plainbox-0.10/plainbox/")]
        tarball.extractall(tmp, members=members)
        copy_tree(
            os.path.join(tmp, "plainbox-0.10", "plainbox"),
            os.path.join('lib', 'py', 'plainbox'),
            preserve_symlinks=1)
    for lib in LIBS_URLS:
        with tempfile.TemporaryDirectory() as tmp:
            get_package_from_url_and_extract(lib, tmp)
            # TODO: remove unwanted files from the extracted tree (e.g. *.h)
            copy_tree(
                os.path.join(tmp, 'usr', 'lib'), 'lib',
                preserve_symlinks=1)
    for pylib in PYTHON3_LIBS_URLS:
        with tempfile.TemporaryDirectory() as tmp:
            get_package_from_url_and_extract(pylib, tmp)
            copy_tree(
                os.path.join(tmp, 'usr', 'lib', 'python3', 'dist-packages'),
                os.path.join('lib', 'py'),
                preserve_symlinks=1)
    for qml_plugin in QML_PLUGINS_URLS:
        with tempfile.TemporaryDirectory() as tmp:
            get_package_from_url_and_extract(qml_plugin, tmp)
            for arch in multiarch_list:
                src = os.path.join(tmp, 'usr', 'lib', arch, 'qt5', 'qml')
                dest = os.path.join('lib', arch)
                if os.path.exists(src) and os.path.isdir(src):
                    copy_tree(src, dest, preserve_symlinks=1)
    # Remove the python3.4 directory
    # currently it only holds a few config-directories with symlinks
    # and those are not used by anything from this location
    shutil.rmtree('lib/python3.4')


if __name__ == "__main__":
    main()
